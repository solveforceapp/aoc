/**
 * ──────────────────────────────────────────────────────────────────────────────
 *  TEMPORAL CONSTITUTION – VOLUME I
 *  Entronomics & Tychronomics: The Laws of Start and Pace
 * ──────────────────────────────────────────────────────────────────────────────
 *
 *  Entronomics governs *entry conditions*: how, when, and under what
 *  constraints a sequence is allowed to begin. Tychronomics governs
 *  *tempo and duration*: the pacing of steps, programs, and performances.
 *
 *  ENTRONOMICS – ECONOMY OF ENTRY:
 *
 *    • Entronomics asks:
 *        - Under what conditions may a program be invoked?
 *        - Must the field first be calibrated (Medianomics)?
 *        - Can alien .logos scores enter directly, or only via review?
 *        - Is the current entropy level low enough to admit a new run?
 *
 *    • In the Sequencer:
 *        - Entronomics is:
 *            - gating of ProgramPlayer actions;
 *            - the choice to run Medianomics Calibration before a tour;
 *            - Condonomic rules that reject unsafe or incoherent .logos imports.
 *
 *    • Entronomic Principle:
 *        No pattern may enter the field without respecting its current state.
 *        Starts are not free; they are budgeted.
 *
 *  TYCHRONOMICS – ECONOMY OF TIME:
 *
 *    • Tychronomics asks:
 *        - How fast should the field evolve?
 *        - What is the step duration (stepMs) for a given program?
 *        - Do tempos change across sections (Crescendo vs Diminution)?
 *        - How long should Grand Tours run?
 *
 *    • In the Sequencer:
 *        - Tychronomics lives in:
 *            - playProgram stepMs;
 *            - performSet chaining delays;
 *            - per-step duration overrides in scores;
 *            - "slow retro" vs "fast forward" runs.
 *
 *    • Tychronomic Principle:
 *        Time is not uniform; tempo is itself a policy. Each session declares
 *        its own temporal contract, and the field obeys.
 *
 *  Together, Entronomics and Tychronomics define *when* the machine moves
 *  and *how fast* it breathes.
 *
 *  Signed in the Ledger of Time Windows – Logos Sequencer Constitution v3.1
 */
/**
 * ──────────────────────────────────────────────────────────────────────────────
 *  TEMPORAL CONSTITUTION – VOLUME II
 *  Orbitronomics & Spanomics: The Laws of Cycle and Reach
 * ──────────────────────────────────────────────────────────────────────────────
 *
 *  Orbitronomics governs *cycles and loops*: how paths recur, orbit, and
 *  revisit territory. Spanomics governs *spans and intervals*: how far
 *  sequences reach and how long they dwell.
 *
 *  ORBITRONOMICS – ECONOMY OF CYCLES:
 *
 *    • Orbitronomics asks:
 *        - Which programs loop, and how often?
 *        - Do we allow endless orbits, or must cycles close?
 *        - How do Möbius Tours braid forward + retro as higher-order orbits?
 *
 *    • In the Sequencer:
 *        - Orbitronomics is:
 *            - performSet ordering (Grand Möbius Tour);
 *            - explicit loops over suites (I→II→III→Retro→...);
 *            - repeated use of ORBIT baseFlow for sustained rotation fields.
 *
 *    • Orbitronic Principle:
 *        No cycle may be eternal; all orbits must either:
 *          (a) resolve to Uenomics, or
 *          (b) be declared as intentionally ongoing practice.
 *
 *  SPANOMICS – ECONOMY OF SPAN:
 *
 *    • Spanomics asks:
 *        - How many steps should a pattern span?
 *        - How many programs should a performance contain?
 *        - How far across the modal wheel should we travel in a run?
 *
 *    • In the Sequencer:
 *        - Spanomics lives in:
 *            - FieldProgram lengths;
 *            - how many modals a suite touches;
 *            - how broad a PerformanceSet (Grand Tour vs micro-etude) is;
 *            - choices like Full Constellation I (maximal span).
 *
 *    • Spanomic Principle:
 *        Both brevity and extensiveness are policies; each run must declare
 *        how wide and how long its exploration will be.
 *
 *  Together, Orbitronomics and Spanomics define *how wide we walk the field*
 *  and *how often we return*.
 *
 *  Signed in the Ledger of Reach – Logos Sequencer Constitution v3.1
 */
/**
 * ──────────────────────────────────────────────────────────────────────────────
 *  TEMPORAL CONSTITUTION – VOLUME III
 *  Panoronomics, Perturnomics, Permeanomics:
 *  The Laws of View, Perturbation, and Permeability
 * ──────────────────────────────────────────────────────────────────────────────
 *
 *  Panoronomics governs *perspective*: what slice of the field we see and at
 *  what scale. Perturnomics governs *perturbation*: how variations and
 *  deviations are introduced. Permeanomics governs *permeability*: how
 *  boundaries allow or resist cross-influence.
 *
 *  PANORONOMICS – ECONOMY OF VIEW:
 *
 *    • Panoronomics asks:
 *        - Are we looking at a single program or the whole repertoire?
 *        - Are we in radial view, linear view, or entropy view?
 *        - How much of the field’s history do we display?
 *
 *    • In the Sequencer:
 *        - Panoronomics expresses itself in:
 *            - RadialModalPalette vs ModalPalette;
 *            - entropy panels vs trails;
 *            - performance vs single etude focus.
 *
 *    • Panoronomic Principle:
 *        Perspective is a choice. The instrument must support both close-up
 *        and wide-angle inspections, and never confuse them.
 *
 *  PERTURNOMICS – ECONOMY OF PERTURBATION:
 *
 *    • Perturnomics asks:
 *        - How much randomness or deviation may we inject?
 *        - When is it appropriate to perturb step order or duration?
 *        - How does improvisation coexist with canonical structure?
 *
 *    • In the Sequencer:
 *        - Perturnomics shows up as:
 *            - randomization of program order in a setlist;
 *            - noiseLevel in VectorFieldProfile;
 *            - ad-hoc activation vs strict `playProgram`.
 *
 *    • Perturnomic Principle:
 *        Deviations are allowed only when they serve exploration without
 *        violating Encodenomic fidelity or Condonomic safety.
 *
 *  PERMEANOMICS – ECONOMY OF PERMEABILITY:
 *
 *    • Permeanomics asks:
 *        - How permeable is the boundary between:
 *            - canonical vs alien scores?
 *            - separate sessions or users?
 *            - geometric domains (Axiom/Cymatic/Lex)?
 *        - Which influences are allowed to cross over, and how far?
 *
 *    • In the Sequencer:
 *        - Permeanomics is:
 *            - `.logos` import policy;
 *            - whether an alien pattern can join CANONICAL_PROGRAMS;
 *            - how often cross-suite weaves are allowed in a single run;
 *            - degree of mixing between domains in PerformanceSets.
 *
 *    • Permeanomic Principle:
 *        The field must remain open enough to learn and closed enough
 *        to stay coherent. Permeability is a governed parameter.
 *
 *  Together, Panoronomics, Perturnomics, and Permeanomics define how the
 *  Sequencer *sees* itself, how it *wiggles*, and how it *lets influence pass*.
 *
 *  Signed in the Ledger of Perspectives – Logos Sequencer Constitution v3.1
 */
/**
 * ──────────────────────────────────────────────────────────────────────────────
 *  WITNOMICS: The Economy of Witness
 * ──────────────────────────────────────────────────────────────────────────────
 *
 *  Witnomics governs observation, testimony, and remembrance in the Logos
 *  Sequencer. It is the ministry that ensures the field does not merely
 *  move, but is *seen* to move—and that its movements can be recalled,
 *  analyzed, and trusted.
 *
 *  PRINCIPLES:
 *
 *  • Witness is part of the system.
 *      The playhead, entropy traces, trails, dev-logs, and .logos archives
 *      are not incidental—they are constitutional witnesses of behavior.
 *
 *  • No claim without trace.
 *      A composition that cannot be replayed or traced (entropy, path,
 *      profile history) cannot be treated as canonical.
 *
 *  • Etudes are sworn testimony.
 *      Audit Etudes (geometric, dynamic, lattice, nomic) are Witnomic
 *      instruments: they produce structured evidence about how the engine
 *      behaves under defined conditions.
 *
 *  • Logs are scripture, not scrap.
 *      Dev-logs and governance snapshots (session intents, performance
 *      records) are part of the Logos polity’s memory, not temporary notes.
 *
 *  APPLICATION:
 *
 *  • Witnomics governs:
 *      - entropy sampling & visualization,
 *      - trail rendering on the radial wheel,
 *      - saved .logos scores,
 *      - GovernanceSnapshot JSON,
 *      - Etude Registry as test canon,
 *      - narrative logs like this very changelog.
 *
 *  Witnomics is the guarantee that the Logos Sequencer is not just powerful,
 *  but *auditable*. It turns behavior into evidence, evidence into insight,
 *  and insight into future law.
 *
 *  Signed in the Ledger of Witness – Logos Sequencer Constitution v3.2
 */
import { useState, useRef, useCallback } from 'react';
import { FieldProgram, FieldProgramStep, ModalKey } from '../src/types';

export type PlaybackMode = 'normal' | 'loop' | 'reverse';

interface ProgramPlayerState {
  isPlaying: boolean;
  activeProgramId: string | null;
  activeStepIndex: number;
  playbackMode: PlaybackMode | null;
}

export function useProgramPlayer(
  activateStep: (step: ModalKey) => void,
  stepInterval: number = 2500
) {
  const [playerState, setPlayerState] = useState<ProgramPlayerState>({
    isPlaying: false,
    activeProgramId: null,
    activeStepIndex: 0,
    playbackMode: null,
  });

  const timerRef = useRef<number | null>(null);

  const stopProgram = useCallback(() => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
    }
    setPlayerState({
      isPlaying: false,
      activeProgramId: null,
      activeStepIndex: 0,
      playbackMode: null,
    });
  }, []);

  const playProgram = useCallback(
    (program: FieldProgram, mode: PlaybackMode = 'normal') => {
      stopProgram(); // Stop any existing program before starting a new one

      if (program.steps.length === 0) return;

      const isReversed = mode === 'reverse';
      const initialStepIndex = isReversed ? program.steps.length - 1 : 0;

      setPlayerState({
        isPlaying: true,
        activeProgramId: program.id,
        activeStepIndex: initialStepIndex,
        playbackMode: mode,
      });

      const runStep = (index: number) => {
        // Termination condition for non-looping modes
        // FIX: Refactored condition to be more explicit and avoid redundant type checks.
        if (
          (mode === 'normal' && index >= program.steps.length) ||
          (mode === 'reverse' && index < 0)
        ) {
          stopProgram();
          return;
        }
        
        // Handle looping logic
        let correctedIndex = index;
        if (mode === 'loop') {
            correctedIndex = (index + program.steps.length) % program.steps.length;
        }

        const stepConfig: FieldProgramStep = program.steps[correctedIndex];
        const key = typeof stepConfig === 'string' ? stepConfig : stepConfig.key;
        const duration = (typeof stepConfig === 'object' && stepConfig.durationMs) ? stepConfig.durationMs : stepInterval;

        setPlayerState(prev => ({
          ...prev,
          activeStepIndex: correctedIndex,
        }));
        activateStep(key);

        const nextIndex = isReversed ? correctedIndex - 1 : correctedIndex + 1;
        
        timerRef.current = window.setTimeout(() => runStep(nextIndex), duration);
      };
      
      runStep(initialStepIndex);
    },
    [activateStep, stepInterval, stopProgram]
  );

  return {
    ...playerState,
    playProgram,
    stopProgram,
  };
}
